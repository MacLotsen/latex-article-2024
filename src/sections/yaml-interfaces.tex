\section{Invoice Templates with \texttt{lua-placeholders}}\label{sec:new situation}
This chapter demonstrates how YAML interfaces, also known as recipes, can be used as interfaces for invoice templates and how they can be linked to \LaTeX.

The ultimate goal is to provide an efficient and customizable invoicing interface that can be easily integrated into an enhanced version of GinVoice.
Figure~\ref{fig:scope-bd} illustrates a representation of the new situation, with all irrelevant techniques for this article crossed out.

\begin{figure}[!ht]
    \centering
    \input{diagrams/scope-bd.tex}
    \caption{Levels within GinVoice}\label{fig:scope-bd}
\end{figure}

Thus, the data, as seen in figure~\ref{fig:classdiagram}, is moved from the application level to the data level.
This allows both Python programmers and \LaTeX\ users to interact with the data level, something that is impossible in the current situation.

\subsection{YAML Specifications}
Based on the data analysis in section~\ref{sec:invoice data}, we can start working with the recipes.
All recipes are placed in the \texttt{recipes} directory relative to the \LaTeX\ project.
Alternatively, you could store the \texttt{recipes} directory under \texttt{\$TEXMFHOME/tex/} to make the recipes available everywhere.

\subsubsection{The Invoice}
The invoice recipe, \texttt{recipes/invoice.yaml}, specifies two relationships: \texttt{supplier} and \texttt{client}, as mentioned earlier in section~\ref{sec:invoice data}.
\lstinputlisting[language=YAML,caption={\texttt{recipes/invoice.yaml}},linerange=1-5,numbers=left,xleftmargin=15pt]{demo/recipes/invoice.yaml}
How the corresponding recipes are loaded based on these values is described in section~\ref{sec:preamble}.

The data within the invoice part can optionally be standardized using a \texttt{default} field, as done for \texttt{title}.
You can even invoke \LaTeX\ from a default value, including other parameters using \cs{param}.
\lstinputlisting[language=YAML,firstnumber=6,linerange=6-21,numbers=left,xleftmargin=15pt]{demo/recipes/invoice.yaml}
In addition to default values, temporary placeholders can also be specified.

The most complex part of the invoice is the invoice table, where you can specify columns just like you do for other data types.
\lstinputlisting[language=YAML,firstnumber=22,linerange=22-37,numbers=left,xleftmargin=15pt]{demo/recipes/invoice.yaml}
As mentioned earlier in section~\ref{sec:invoice data}, for most \LaTeX\ users, the \texttt{total} column can be omitted and calculated using a package like \texttt{invoice2}.
Additionally, it is necessary to make the \texttt{quantity} field of type \texttt{number} and add an extra field like \texttt{quantity type}, so that you can display the correct notation for the \texttt{quantity} column.

For the final totals, I chose the type \texttt{object} so that I can manually set the different totals in \LaTeX.
\lstinputlisting[language=YAML,firstnumber=38,linerange=38-49,numbers=left,xleftmargin=15pt]{demo/recipes/invoice.yaml}
The final totals could also be handled in a more generic way, like the \texttt{extra fields} field in the supplier recipe (see section~\ref{sec:supplier spec}).

The last field of the invoice, \texttt{message}, uses a special YAML feature — multiline strings — in the default value.
\lstinputlisting[language=YAML,firstnumber=50,linerange=50-,numbers=left,xleftmargin=15pt]{demo/recipes/invoice.yaml}
Using the pipe (\texttt{|}) activates this mode.
This construction is ideal for large texts, possibly with \LaTeX\ syntax.

\subsubsection{Client}
The client data does not have any special specifications compared to the invoice.
\lstinputlisting[language=YAML,caption={\texttt{recipes/client.yaml}},numbers=left,xleftmargin=15pt]{demo/recipes/client.yaml}
Alternatively, all address details could be specified as a \texttt{list} type, along with a specification, as seen in \texttt{extra fields} in the supplier recipe.
This would make the interface more generic but less adaptable within the \LaTeX\ context.

\subsubsection{Supplier}\label{sec:supplier spec}
In the case of the recipe for the supplier, the \texttt{style} field serves the same function as \texttt{supplier} and \texttt{client} of the invoice, allowing the user to choose which style to apply.
\lstinputlisting[language=YAML,caption={\texttt{recipes/supplier.yaml}},numbers=left,xleftmargin=15pt]{demo/recipes/supplier.yaml}

Another interesting field in this specification is \texttt{extra fields}.
This field uses the \texttt{table} type to allow additional information fields, such as the supplier's account number, VAT number, or other relevant details.
Using a table instead of a fixed number of fields gives the end-user the flexibility to add as much extra information as needed, without imposing restrictions.

\subsubsection{Style}
In the style recipe, fonts, colors, and multiple images can be specified.
As mentioned earlier: for \LaTeX\ users, this could be fully specified in \LaTeX\ itself.
The style recipe could then be omitted.
\lstinputlisting[language=YAML,caption={\texttt{recipes/style.yaml}},numbers=left,xleftmargin=15pt]{demo/recipes/style.yaml}
Remarkable is the type for \texttt{images}, namely \texttt{list}.
In section~\ref{sec:typesetting}, you can see how this list is loaded at the bottom of the invoice.

\subsection{The New Invoice}
Now that the recipes are in order, we can proceed to integrate them into \LaTeX.

\subsubsection{Loading Recipes in the Preamble}
The recipes are loaded using the \cs{loadrecipe} macro.
\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=44,linerange=44-47]{demo/invoice.tex}
For the \texttt{invoice} recipe, you can see that it is given the \meta{namespace} \cs{jobname}.
This is because the \cs{param} macro by default uses \cs{jobname} as the \meta{namespace}, simplifying its use.

The other recipes do not specify a \meta{namespace}, meaning they carry the 'basename' of the path as the \meta{namespace}.
In this case, respectively, \texttt{supplier}, \texttt{client}, and \texttt{style}.

\subsubsection{Currency}
Regarding the currency, I have chosen to disguise it in the \cs{currency} macro.
This is because it is also used in

 other files, such as \texttt{invoice.cls}.
\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=49,linerange=49-49]{demo/invoice.tex}
If the \meta{currency} is not set, the default value from \texttt{style.yaml} is used.
In this case, it defaults to \cs{EUR}.

\subsubsection{Loading Values}\label{sec:preamble}
I've chosen to manage all YAML files related to the data in corresponding directories.\\
\dirtree{%
    .1 \meta{project name}.
    .2 recipes.
    .3 \meta{recipe}.yaml.
    .2 invoices.
    .3 \meta{invoice-xxx}.yaml.
    .2 clients.
    .2 \textit{et cetera}.
}
\noindent
Values, also called the payload, are loaded similar to recipes but with the \cs{loadpayload} macro.
Due to the relationships described in section~\ref{sec:invoice data}, it is slightly more complex than recipes because \pkg{lua-placeholders} does not offer anything standard for this.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=51,linerange=51-54]{demo/invoice.tex}
For loading invoice values, it is checked whether a corresponding YAML file exists.
If so, that payload is loaded, and the experimental macro \cs{strictparams} is used, which will mean that errors will occur in the future if mandatory data is missing.

If no corresponding file is found, an invoice template is compiled.

After loading the invoice data, we can check if a client is specified in the invoice data.
We do this using \cs{hasparam}.
This concerns the invoice data, for which we do not need to specify a \meta{namespace}.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=56,linerange=56-58]{demo/invoice.tex}
Generally, \cs{param} is not intended for use within the preamble because it can also yield placeholders with \LaTeX\ markup.
For such difficult situations, the macro \cs{rawparam} is written, as done for the client and supplier.
This macro has no optional arguments, which often causes problems with, for example, \texttt{pgfkeys}.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=60,linerange=60-62]{demo/invoice.tex}
As you can see, loading the supplier does not differ from loading the client.
However, there is a follow-up action after loading the supplier, namely checking if the style can be loaded.
This is done in the same way as with the client and supplier themselves, but here you see that the \meta{namespace} must be set.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=64,linerange=64-72]{demo/invoice.tex}
For the style-related data, I chose to configure the values directly in the corresponding macros, such as \cs{setmainfont} and \cs{definecolor}, as long as a style is specified.
You could also choose to set the style values by default based on the default values specified in the \texttt{style} recipe, by placing the configuration outside the \cs{hasparam} block.

\subsection{Processing in the Document}\label{sec:typesetting}
Before we can move on to compiling invoices, we have one more task: setting all values in the document itself.

\subsubsection{Header}
As mentioned earlier in chapter~\ref{sec:ginvoice}, the \cs{makeheader} macro comes from \texttt{invoice.cls}.
For now, we assume that \texttt{invoice.cls} has been adjusted so that it no longer causes errors and that \cs{makeheader} now expects the title and subtitle as arguments:

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=76,linerange=76-79]{demo/invoice.tex}
In the example, there are only two differences compared to the previous version: \\
\cs{title}\hfill\textrightarrow\hfill\lstinline[language={[LaTeX]TeX}]|\param{title}|\\
\cs{subtitle}\hfill\textrightarrow\hfill\lstinline[language={[LaTeX]TeX}]|\param{subtitle}|\\
However, this time passed correctly to the \texttt{document\-class}.

\subsubsection{Information}
The left column of the information is quite tricky, as it contains both client information and invoice data, such as the number and date.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=15pt,firstnumber=80,linerange=80-91]{demo/invoice.tex}
You can see in the address lines that a line break is set for each line.
This could also have been done if, for example, a field \texttt{address lines} of type \texttt{list} was present.
Then it would have been solved in one go with \lstinline|\param[client]{address lines}|, assuming that \texttt{postal} and \texttt{place} are merged on one line in YAML.
The alternative mentioned assumes that the \cs{paramlistconjunction} macro is set to `\texttt{\textbackslash\textbackslash}', instead of the default `\texttt{,\~}'.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=20pt,firstnumber=92,linerange=92-101]{demo/invoice.tex}
The right column of information is similar to the left, only it has one additional special field, namely \texttt{extra fields} of type \texttt{table}.
This allows for a variable number of rows to be added.
The same could potentially be applied to the client details in the left column.
Then only the choice remains whether to place them above or below the invoice information.

\subsubsection{Table}
As mentioned earlier, standardizing the column definition is difficult.

On line 105, you can see what the \cs{columdefs} could have provided, except for the counters that I previously used.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=20pt,firstnumber=103,linerange=103-105]{demo/invoice.tex}

For the second argument of the \texttt{invoice} environment, a static header is set.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=20pt,firstnumber=106,linerange=106-107]{demo/invoice.tex}

For the third argument of the \texttt{invoice} environment, you can see how the final totals are set in the table.
These totals are placed in the last two columns of each row, so that they align neatly with the rest of the table.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=20pt,firstnumber=108,linerange=108-113]{demo/invoice.tex}

In the final part of the table, you can see how each invoice line is set using \cs{fortablerow} with the help of \cs{formatrecords}.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=20pt,firstnumber=114,linerange=114-119]{demo/invoice.tex}

The overall structure of the table is still from the previous situation.
The notable difference from the old situation is that the data can be put into all sorts of table structures, since the data is decoupled from the \LaTeX\ and application domains, and the challenges of typesetting are shifted to the \LaTeX\ domain.

\subsubsection{Closing Text and Images}
Where we previously saw an advanced YAML specification for the \texttt{message} field, the implementation in \LaTeX\ remains virtually the same:

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=20pt,firstnumber=121,linerange=121]{demo/invoice.tex}

The only difference is:\\
\cs{theending}\hfill\textrightarrow\hfill\lstinline|\param{message}|\\

The images, on the other hand, are slightly more difficult to implement in \LaTeX\ due to the \texttt{list} type.

\lstinputlisting[language={[LaTeX]TeX},numbers=left,xleftmargin=20pt,firstnumber=122,linerange=122-]{demo/invoice.tex}

Where previously in Python all images were neatly placed next to each other, with a \cs{hspace} of \texttt{1.5em} between each image, I chose to use half of that as \cs{hspace} on each side of each image.
This is because the \cs{forlistitem} macro does not yet have a convenient way for that, like \cs{param} does by setting \cs{paramlistconjunction} to `\lstinline|\hspace{1.5em}|'.
